# 游戏引擎架构设计

## 📁 代码组织

```
src/
├── core/           # 核心管理器
├── state/          # 状态管理
├── render/         # 渲染相关
├── response/       # 事件响应处理
├── commands/       # 游戏指令
├── config/         # 配置定义
├── types/          # 类型定义
├── utils/          # 工具类
└── logic/          # 业务逻辑
```

## 🏗️ 模块职责与交互

### core/ - 核心模块
- 作为整个游戏的中枢，协调其他模块的工作
- 维护游戏主循环，处理生命周期
- 通过事件系统与其他模块通信
- 负责初始化和管理其他模块的实例

### state/ - 状态管理
- 维护游戏实体的状态数据
- 不直接处理业务逻辑，只提供状态的读写接口
- 可以监听其他状态的变更事件并作出响应
- 状态之间可以通过事件机制进行通信
- 响应来自指令系统的状态更新请求

### render/ - 渲染模块
- 直接从状态管理器获取最新状态
- 根据状态数据更新画面
- 不包含游戏逻辑，纯粹的视图层
- 提供调试视图支持

### response/ - 响应处理
- 处理各类游戏事件的响应逻辑
- 可以触发新的事件或发出指令
- 与状态管理器交互，更新游戏状态
- 处理用户输入和游戏规则判定

### commands/ - 指令系统
- 封装具体的游戏操作逻辑
- 可以调用其他指令，组合复杂操作
- 直接访问状态管理器更新状态
- 可以触发新的事件

### config/ - 配置模块
- 定义游戏的配置结构
- 提供配置的读取和验证
- 支持运行时配置更新
- 被其他模块引用，提供配置数据

### types/ - 类型定义
- 集中管理所有类型定义
- 被其他模块引用，提供类型支持
- 确保代码的类型安全
- 便于维护和重构

### utils/ - 工具模块
- 提供通用功能支持
- 不涉及具体游戏逻辑
- 被其他模块复用
- 提供日志、计算等通用功能

### logic/ - 业务逻辑
- 实现具体的游戏规则
- 依赖于状态管理器
- 可以发出指令或触发事件
- 处理复杂的业务规则判定

## 🔄 模块交互流程

1. **输入处理流程**
   - 用户输入 → response/InputHandler
   - InputHandler → commands/
   - commands/ → state/
   - state/ 更新状态并触发事件
   - 其他状态可能响应这些事件

2. **渲染更新流程**
   - state/ 状态更新
   - render/ 直接读取状态
   - render/ 更新画面

3. **游戏逻辑流程**
   - logic/ 处理游戏规则
   - 通过 commands/ 发出指令
   - commands/ 可能调用其他指令
   - 更新 state/ 中的状态
   - 状态更新可能触发其他状态的变化

## 📦 模块设计原则

1. **单向数据流**
   - 状态更新统一通过指令系统
   - 渲染层直接读取状态
   - 状态间可通过事件通信
   - 避免模块间直接修改数据

2. **关注点分离**
   - 每个模块职责单一
   - 通过接口通信
   - 降低模块耦合度

3. **事件驱动**
   - 部分模块间通过事件通信
   - 状态管理器之间可以通过事件交互
   - 支持异步操作
   - 便于扩展和维护 